#!/usr/bin/env python
# -*- coding: utf-8 -*-
# everything but the kitchen sink to ease portability when reqd.
from __future__ import print_function, absolute_import, division, unicode_literals
import markdown
import codecs
import ukedown.udn

# jinja2 templating, originially based one the django model.
from jinja2 import Environment, FileSystemLoader

# for generating summary info
from bs4 import BeautifulSoup as bs

# the normal boring stuff
import sys
import os

import argparse

def parse_commandline(argv):
    """
    Define commandline options and arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("input", nargs="+", help="name of input file(s) to process")
    parser.add_argument("-s", "--style", help="output style, must correspond to a stylesheet in the css dir", choices=['weds', 'belfast', 'karauke', 'singers'], default='weds')
    parser.add_argument("-o", "--output", help="Output file to create [autogenerated]")
    parser.add_argument("--stylesheet", help="provide a custom stylesheet to test rendering. Expects to be given a path.")
    parser.add_argument("--template", help="provide a custom template to test rendering. Expects to be given a path")
    parser.add_argument("--stdout", help="render to stdout for testing", action="store_true", default=False)

    args = parser.parse_args(argv)

    if len(args.input) > 1 and args.output:
        print ("--output makes no sense with more than one inputfile, ignoring it")
        args.output = None

    return args

def render(template, context, template_dir="templates"):
    """
    Creates a custom jinja2 environment and generates the provided template - allows for customisation

    Args:
        template(str): name of template file
        context(dict): dictionary of key,value pairs to use inside template

    Kwargs:
        template_dir(str): where to look for templates, default is the local 'templates' directory.

    """
    j2env = Environment(loader=FileSystemLoader(template_dir))

    tpl = j2env.get_template(template)

    return tpl.render(context)

def ukedown_to_html(inputfile):

    fh = codecs.open(inputfile, mode="r", encoding="utf-8")
    txt = fh.read()

    return markdown.markdown(txt, extensions=['markdown.extensions.nl2br', 'ukedown.udn'])

def main(options):
    """
    main script entrypoint, expects an 'options' object from argparse.ArgumentParser
    """
    for f in options.input:
        try:
            ctx = {}
            html = ukedown_to_html(f)
            # process that with bs4? Find the classes you require?
            # to generate metadata?
            soup = bs(html, features="lxml")
            # find the chords and associate them with diagrams
            chords = []
            for crd in [c.text.split().pop(0) for c in soup.findAll('span', {'class': 'chord'})]:
                # we only want the first word
                c = crd.split().pop(0)

                # munge filenames, '/' -> 'slash',
                # '#' -> 'sharp'
                if '/' in c:
                    c.replace('/', 'slash')
                if '#' in c:
                    c.replace('#', 'sharp')
                if c not in chords:
                    chords.append(c)
            ctx['chords'] = chords
            # extract first h1 tag and make it the document title, with optional artist
            # there should only be one of these anyway, even if not, we'll extract the first as song title
            hdr = soup.h1.extract()
            if '-' in hdr.text:
                ctx['title'], ctx['artist'] = hdr.text.split(' - ', 1)
            else:
                ctx['title'] = hdr.text.strip()

            # remove it from the document, we'll render it differently
            hdr.decompose()

            # print(ctx)
            ctx['html'] = unicode(soup)

            out = render("ukesong.j2", ctx)
            if opts.stdout:
                print (codecs.encode(out, "utf-8"))
            else:
                output = opts.output
                if not output:
                    output = "%s.html" % os.path.splitext(f)[0]

                with codecs.open(output, mode='wb', encoding="utf-8") as fd:
                    fd.write(out)


        except (IOError, OSError), E:
            print ("oops - couldn't render %s (%s)" % (E.filename, E.strerror))

        except:
            # all other errors
            raise

if __name__ == "__main__":
    opts = parse_commandline(sys.argv[1:])
    main(opts)


